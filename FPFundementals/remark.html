<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

      .remark-slide-number { display: none; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# FP Fundamentals
## Functors, monads and more
<br>
<center><small>Tom Duncalf | <a href='mailto:tom@tomduncalf.com'>tom@tomduncalf.com</a> | <a href='https://twitter.com/tomduncalf'>@tomduncalf</a></small></center>

---

### Why?

* A lot of interest in FP at the minute
* Some of the fundamental concepts (functors, monads etc.) are sometimes made to seem very complicated
* The basic concepts are actually quite simple (and useful)
* Don't have to use a pure FP language - examples in Javascript
* I am not an expert :)
* Toolkit which makes writing functional programs good

---

### The book this is based on

<center>
  <img src='./book.png' width='50%'>
  <br/>
  <small>https://github.com/MostlyAdequate/mostly-adequate-guide</small>
</center>

---

### Concepts we'll cover

* Pure functions
* First class functions
* Hindley-Milner type signatures
* Currying
* Composition
* Pointfree style
* Functors
* Monads

---

### Pure functions

--

* A pure function is a function that, given the same input, will always return the same output and does not have any observable side effect.

---

### Pure functions

* <span style='opacity:0.3'>A pure function is a function that, </span>given the same input, will always return the same output <span style='opacity:0.3'>and does not have any observable side effect.</span>
<center><img src='function.gif' height='30%'></center>

---

### Pure functions

* A pure function is a function that, given the same input, will always return the same output and does not have any observable side effect.
<center><img src='function.gif' height='30%'></center>
* No dependence on factors external to the input

---

### Pure functions

* Side effect: "anything that occurs in our computation besides the calculation of a result"
* "Side effects are a primary cause of incorrect behaviour"
--

* Examples include:
  * changing the file system
  * inserting a record into a database
  * making an http call
  * printing to the screen / logging
  * obtaining user input
  * querying the DOM
  * any interaction with the world outside of the function!

---

### Pure functions

* How can we program without side effects?
  * We can't - we aim to control them and run them in a controlled manner
  * more on this later...

---

### Why pure functions?

* <b>Cacheable</b> (memoization): we know the same input will always give the same output
--

* <b>Portable</b>: a function's dependencies are explicit
--

* <b>Testable</b>: we don't need to mock complex dependencies, just assert outputs given inputs
--

* <b>Referential transparency</b>: code can be substituted for its generated value
--

* <b>Parallelisable</b>: do not need access to shared memory, no race conditions

---

### Hindley-Milner type signatures

--

* Specifies what types of inputs a function takes and what type it returns
--

* JS has no type checking but useful for documentation
* Can often understand what a function does just from name and type signature
* Can be useful for searching for a function e.g. Ramda docs, Hoogle

---

### Hindley-Milner type signatures

```
// stringLength :: String -> Number
const stringLength = input => {
    return stringLength.length
}
```

--

```
// splitWords :: String -> [String]
const splitWords = input => {
    return input.split(' ')
}
```

--

```
// splitByCharacter :: String -> String -> [String]
const splitByCharacter = (input, char) => {
    return input.split(char)
}
```

--

```
// splitAndTransformWords :: String -> (String -> String) -> [String]
const splitAndTransformWords = (input, transformFn) => {
    return s.split(' ').map(word => transformFn(word))
}
```

--

```
// transformArray :: [a] -> (a -> b) -> [b]
const transformArray = (inputArray, transformFn) => {
    return inputArray.map(el => transformFn(el))
}
```

---

### First class functions

---

### First class functions

* Functions are treated just like any other data type
* They can be passed around, stored in variables, arrays, etc.
* They are only called when invoked with `()`

--

```
// hi :: String -> String
const hi = name => {
    return "Hi " + name
}
```

--

```
// This:
// greet :: String -> String
const greet = name => {
  return hi(name)
}

// or this:
// greet :: String -> String
const greet = name => hi(name)
```

--

```
// ...is the same as:
// greet :: String -> String
const greet = hi
```

---

### First class functions

```
// This:
// transformArray :: [a] -> (a -> b) -> [b]
const transformArray = (inputArray, transformFn) => {
    return inputArray.map(el => transformFn(el))
}
```

--

```
// ...is the same as:
// transformArray :: [a] -> (a -> b) -> [b]
const transformArray = (inputArray, transformFn) => {
    return inputArray.map(transformFn)
}

// or:
// transformArray :: [a] -> (a -> b) -> [b]
const transformArray = (inputArray, transformFn) => inputArray.map(transformFn)
```

--

```
// This:
transformArray(['one', 'two', 'three'], x => x.length)
```

--

```
// ...is the same as:
// length :: a -> Number
const length = x => x.length
transformArray(['one', 'two', 'three'], length)
```

---

### Why first class functions?

* Less code, more readable
* Easier to change function arguments - no need to update everywhere
* Reduces the need to name arguments which allows us to write more generic code - common theme in FP

--

```
// Specific to our current domain:
// validArticles :: [a] -> [a]
const validArticles = articles => {
  return articles.filter(article => article !== null && article !== undefined)
}

// Generic and reusable:
// compact :: [a] -> [a]
const compact = xs => {
  return xs.filter(x !== null && x !== undefined)
}
```

---

### Currying

--

* A curried function can be called with fewer arguments than it expects, and will return a function that takes the remaining arguments

---

### Currying

* A curried function can be called with fewer arguments than it expects, and will return a partially applied function that takes the remaining arguments

--

```
// add :: a -> (a -> a) - e.g. Number -> (Number -> Number)
const add = (x) => {
  return (y) => {
    return x + y
  }
}

// Or...
// add :: a -> (a -> a)
const add = x => y => x + y
```

--

```
add(1) // returns: function(y) => { return x + y }
add(1)(2) // returns: 3
```

--

```
// addOne :: Number -> Number
const addOne = add(1)
// addTen :: Number -> Number
const addTen = add(10)

addOne(2) // returns: 3
addTen(2) // returns: 12
```

---

### Currying

* `curry` (for `n` arguments) is included in `lodash` and `ramda`

--

* Order of arguments is important - the data should come last so we can "pre-fill" the function <small>(see <a href='https://www.youtube.com/watch?v=m3svKOdZijA'>Hey Underscore, You're Doing It Wrong!</a>)</small>

    Consider: `_.indexOf(array, search)` vs `_.indexOf(search, array)`

  * Although we could use `_.curryRight`, better off using `lodash/fp` or `ramda` (all functions pre-curried)

---

### Why currying?

--

* Allows us to easily make new domain functions from generic ones

```
// isGmailAddress :: String -> Boolean
const isGmailAddress = R.test(new RegExp('@gmail.com$'))
isGmailAddress('test@gmail.com') // returns: true
isGmailAddress('test@hotmail.com') // returns: false
```

--

* Helps avoid the overhead of passing arguments around all the time

```
// sendEmail :: Object -> String -> String -> String -> Boolean
const sendEmail = (mailService, address, subject, body) => R.curry(...)

// Repetitive:
sendEmail(myMailService, adminEmail, errorSubject, 'Error 123 occured')
sendEmail(myMailService, adminEmail, errorSubject, 'Error 456 occured')
```
--

```
// Returns a new function, waiting for the body argument before invoking sendEmail
// sendErrorEmail :: String -> Boolean
const emailError = sendEmail(myMailService, adminEmail, errorSubject)

// Better!
emailError('Error 123 occured')
```
---

### Why currying?

* Can transform any function that works with single elements into one that works on arrays using curried `map`

--

```
// map :: (a -> b) -> [a] -> [b]
const map = R.curry(fn, array => array.map(fn)) // or just R.map...
```
--

````
const strings = ['apple', 'banana', 'raspberry']

// isApple :: String -> Boolean
const isApple = input => input === 'apple' // or R.equals('apple')

// areApples :: [String] -> [Boolean]
const areApples = map(isApple)

// All equivalent: return [true, false, false]
areApples(strings)
map(isApple)(strings)
strings.map(string => isApple(string))
```

--

* Benefits are less obvious with ES6 syntax than ES5, but currying becomes powerful when combined with other functional tools

```
strings.map(function(string) {
  return lengthGt5(string)
})
```

---

### How is currying pure?

* Each single argument of the function returns a new function expecting the remaining arguments
--

* Always returns the same function for the same input argument, so still pure: 1 input maps to exactly 1 ouptut

<center><img src='function.gif' height='30%'></center>
--

* Allowing more than one argument at a time can be seen as a convenience

```
doSomething(1)(2)(3) === doSomething(1, 2, 3)
```

---

### Composition

--

* Composition starts to demonstrate the power of working with pure, first class, curried functions

--

```
// compose :: (b -> c) -> (a -> b) -> (a -> c)
const compose = (f, g) => {
  return x => f(g(x))
}
```

* `f` and `g` are functions, `x` is the value being piped through them

--

```
// head :: [a] -> a
const head = x => x[0]
// reverse :: [a] -> [a]
const reverse = x => x.reverse()

// last :: [a] -> a
const last = compose(head, reverse) // equivalent to: x => head(reverse(x))

last([1, 2, 3]) // returns: 3
```

* Data flows from right to left (first call `reverse`, then `head`)

--

* `ramda` and `lodash` provide generic `compose` for `n` functions (`R.compose`, `_.flowRight` - and `R.pipe` or `_.flow` for left to right flow)

---

### Composition example

* Split a sentence into words, filter out words < 3 chars, calculate average word length, log it

```
// average :: [Number] -> Number
const average = numbers => R.sum(numbers) / numbers.length
// log :: String -> Void
const log = console.log
```

--

Without composition:
```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input => {
  const words = input.split(' ')
  const wordLengths = words.map(word => word.length)
  const filteredLength = wordLength.filter(length => length > 3)
  const avgWordLength = avearage(filteredLength)
  log(avgWordLength)
}
```

--

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(input.split(' ').map(w => w.length).filter(l => l > 3)))
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(input.split(' ').map(w => w.length).filter(l => l > 3)))
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(`input.split(' ')`.map(w => w.length).filter(l => l > 3)))
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(input.split(' ')`.map(w => w.length)`.filter(l => l > 3)))
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(input.split(' ').map(w => w.length)`.filter(l => l > 3)`))
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(`average`(input.split(' ').map(w => w.length).filter(l => l > 3)))
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  `log`(average(input.split(' ').map(w => w.length).filter(l => l > 3)))
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(input.split(' ').map(w => w.length).filter(l => l > 3)))
```

With functions:
```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(R.filter(R.lt(3), R.map(R.length, R.split(' ', input)))))
```

--

With composition (and curried functions):

```
// avgBigWordLength :: String -> Number
const avgBigWordLength =
  R.compose(log, average, R.filter(R.lt(3)), R.map(R.length), R.split(' '))
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(input.split(' ').map(w => w.length).filter(l => l > 3)))
```

With composition (and curried functions):

```
// avgBigWordLength :: String -> Number
const avgBigWordLength =
  `R.compose`(log, average, R.filter(R.lt(3)), R.map(R.length), R.split(' '))
```

```
avgBigWordLength('Hello world how are you?')     // input is String
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(input.split(' ').map(w => w.length).filter(l => l > 3)))
```

With composition (and curried functions):

```
// avgBigWordLength :: String -> Number
const avgBigWordLength =
  R.compose(log, average, R.filter(R.lt(3)), R.map(R.length), `R.split(' ')`)
```


```
avgBigWordLength('Hello world how are you?')     // input is String
// split:         ['hello', 'world', 'how', 'are', 'you?']  [String]
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(input.split(' ').map(w => w.length).filter(l => l > 3)))
```

With composition (and curried functions):

```
// avgBigWordLength :: String -> Number
const avgBigWordLength =
  R.compose(log, average, R.filter(R.lt(3)), `R.map(R.length)`, R.split(' '))
```

```
avgBigWordLength('Hello world how are you?')     // input is String
// split:         ['hello', 'world', 'how', 'are', 'you?']  [String]
// map(length):   [5, 5, 3, 3, 4]                           [Number]
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(input.split(' ').map(w => w.length).filter(l => l > 3)))
```

With composition (and curried functions):

```
// avgBigWordLength :: String -> Number
const avgBigWordLength =
  R.compose(log, average, `R.filter(R.lt(3))`, R.map(R.length), R.split(' '))
```

```
avgBigWordLength('Hello world how are you?')     // input is String
// split:         ['hello', 'world', 'how', 'are', 'you?']  [String]
// map(length):   [5, 5, 3, 3, 4]                           [Number]
// filter(lt(3)): [5, 5]                                    [Number]
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(input.split(' ').map(w => w.length).filter(l => l > 3)))
```

With composition (and curried functions):

```
// avgBigWordLength :: String -> Number
const avgBigWordLength =
  R.compose(log, `average`, R.filter(R.lt(3)), R.map(R.length), R.split(' '))
```

```
avgBigWordLength('Hello world how are you?')     // input is String
// split:         ['hello', 'world', 'how', 'are', 'you?']  [String]
// map(length):   [5, 5, 3, 3, 4]                           [Number]
// filter(lt(3)): [5, 5]                                    [Number]
// average:       5                                          Number
```
---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(input.split(' ').map(w => w.length).filter(l => l > 3)))
```

With composition (and curried functions):

```
// avgBigWordLength :: String -> Number
const avgBigWordLength =
  R.compose(`log`, average, R.filter(R.lt(3)), R.map(R.length), R.split(' '))
```

```
avgBigWordLength('Hello world how are you?')     // input is String
// split:         ['hello', 'world', 'how', 'are', 'you?']  [String]
// map(length):   [5, 5, 3, 3, 4]                           [Number]
// filter(lt(3)): [5, 5]                                    [Number]
// average:       5                                          Number
// log:           5                                          Number
```

--

* "Pointfree" style: doesn't mention the data we are operating on

--

* Type can change multiple times

--

* More readable, more compact, clear flow of data along "pipeline", no placeholder variables

---

### Composition

* Composition of pure functions mirrors mathematical function composition: <em>(g ∘ f)(x) = g(f(x))</em> (generalized in category theory)

--

* Composition is associative: <em>f ∘ (g ∘ h) = (f ∘ g) ∘ h</em>

--
* We can extract any group of functions into their own composition:

```
// avgBigWordLength :: String -> Number
const avgBigWordLength =
  R.compose(log, average, `R.filter(R.lt(3)), R.map(R.length)`, R.split(' '))
```

--

```
const lengthsLt3 = R.compose(`R.filter(R.lt(3)), R.map(R.length)`)
const avgBigWordLength = R.compose(log, average, `lengthsLt3`, R.split(' '))
```

--

* Can refactor with mathematical rules to back it up!

---

### Composition

* But how do we handle potential errors?

--

```
const address1 = { street: 'Test Street', postcode: 'A1 1AA' }
const address2 = { street: 'Test Street' }

// R.prop :: b -> {b: a} -> a | Undefined
R.prop('postcode', address1) // returns: 'A1 1AA'
R.prop('postcode', address2) // returns: undefined
```

--

```
// postcodeLength :: Object -> Number | ???
const postcodeLength = R.compose(R.length, R.replace(/ /, ''), R.prop('postcode'))
```

--

```
postcodeLength(address1) // returns: 5
postcodeLength(address2) // Exception: Cannot read property 'replace' of undefined
```

--

* We don't want exceptions in our code
* Could wrap `replace` in a function with a null test... but we don't want to do this all the time
--

* And what about handling side effects?!

---

### Functors



    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        highlightLanguage: 'javascript',
        highlightSpans: true
      });
    </script>
  </body>
</html>
